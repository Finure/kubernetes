---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: semver
  namespace: tekton-pipelines
spec:
  params:
    - name: git-branch
      type: string
    - name: pr-number
      type: string
      default: ""
    - name: pipeline-mode
      type: string
    - name: repo-name
      type: string
    - name: userHome
      description: |
        Absolute path to the user's home directory.
      type: string
      default: "/home/git"
  workspaces:
    - name: shared-workspace
    - name: github
  results:
    - name: version
      description: The semantic version to use
    - name: version-type
      description: The type of version (release, prerelease, development)
  steps:
    - name: determine-version
      image: alpine/semver:7.5.4
      env:
      - name: HOME
        value: "$(params.userHome)"
      workingDir: $(workspaces.shared-workspace.path)
      script: |
        #!/bin/sh
        set -e
        # Install dependencies and configure git
        apk add --no-cache git curl jq 
        git config --global --add safe.directory "$(workspaces.shared-workspace.path)"

        # Get latest tag from repo
        git fetch --unshallow || true
        git fetch origin main --tags
        LATEST_TAG=$(git tag --sort=-creatordate | head -n1)
        echo "LATEST: $LATEST_TAG"
        if [ -z "$LATEST_TAG" ]; then
            # No tag exists - use 1.0.0
            NEW_VERSION="1.0.0"
            BUMP_TYPE="initial"
            echo "No existing tag, using initial version: $NEW_VERSION"
            echo "Final version: $NEW_VERSION"
            echo -n "$NEW_VERSION" > "$(results.version.path)"
            exit 0
        else
            echo "Latest version: $LATEST_TAG"
            
        MERGE_BASE=$(git merge-base "$LATEST_TAG" HEAD)

        if [ -z "$MERGE_BASE" ]; then
            echo "Warning: No common ancestor found"
            # Fallback to linear log (may miss commits inside merges)
            MERGE_COMMIT=$(git log "$LATEST_TAG"..HEAD --pretty=format:"%s" --no-merges)
        else
            # Recommended full graph walk
            MERGE_COMMIT=$(git log "$MERGE_BASE"..HEAD --pretty=format:"%s" --no-merges)
        fi
        echo "$MERGE_COMMIT"

            if [ -n "$MERGE_COMMIT" ]; then
                major_count=$(echo "$MERGE_COMMIT" | grep -E "(BREAKING CHANGE|!)" | wc -l)
                minor_count=$(echo "$MERGE_COMMIT" | grep -E "^feat" | wc -l)
                patch_count=$(echo "$MERGE_COMMIT" | grep -E "^fix" | wc -l)
                IFS='.' read -r major minor patch <<EOF
            $LATEST_TAG
            EOF
                # Determine bump type
                BUMP_TYPE=""
                if echo "$MERGE_COMMIT" | grep "(BREAKING CHANGE|!)"; then
                    BUMP_TYPE="major"
                elif echo "$MERGE_COMMIT" | grep "feat"; then
                    BUMP_TYPE="minor"
                elif echo "$MERGE_COMMIT" | grep "fix"; then
                    BUMP_TYPE="patch"
                fi
                
                if [ -n "$BUMP_TYPE" ]; then
                    # Calculate new version
                    IFS='.' read -r major minor patch << EOF
        $LATEST_TAG
        EOF
                if [ "$major_count" -gt 0 ]; then
                    # Breaking change resets minor/patch
                    new_major=$((major + 1))
                    new_minor=0
                    new_patch=0
                    BUMP_TYPE="major"
                else
                    new_major=$major
                    new_minor=$((minor + minor_count))
                    new_patch=$((patch + patch_count))

                    if [ "$minor_count" -gt 0 ]; then
                        BUMP_TYPE="minor"
                    elif [ "$patch_count" -gt 0 ]; then
                        BUMP_TYPE="patch"
                    else
                        # Force patch bump if nothing matched
                        new_patch=$((patch + 1))
                        BUMP_TYPE="patch"
                    fi
                fi

                NEW_VERSION="${new_major}.${new_minor}.${new_patch}"
                echo "Bump type: $BUMP_TYPE"
            else
                # No commits since last tag, force patch bump
                IFS='.' read -r major minor patch <<EOF
            $LATEST_TAG
            EOF
                NEW_VERSION="$major.$minor.$((patch + 1))"
                BUMP_TYPE="patch"
                echo "No commits since last tag, minimum patch bump"
            fi
        fi

        echo "Final version: $NEW_VERSION"

        # Write results
        echo -n "$NEW_VERSION" > $(results.version.path)
        echo -n "$BUMP_TYPE" > $(results.version-type.path)